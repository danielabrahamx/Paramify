"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PARITYPR_DOCKER_REGISTRY = void 0;
exports.constructCommandArgs = constructCommandArgs;
exports.isPortAvailable = isPortAvailable;
exports.getAvailablePort = getAvailablePort;
exports.adjustTaskArgsForPort = adjustTaskArgsForPort;
exports.getNetworkConfig = getNetworkConfig;
exports.configureNetwork = configureNetwork;
exports.startServer = startServer;
exports.getLatestImageName = getLatestImageName;
const axios_1 = __importDefault(require("axios"));
const net_1 = __importDefault(require("net"));
const construction_1 = require("hardhat/internal/core/providers/construction");
const lru_cache_1 = require("lru-cache");
const constants_1 = require("./constants");
const errors_1 = require("./errors");
const servers_1 = require("./servers");
exports.PARITYPR_DOCKER_REGISTRY = "https://registry.hub.docker.com/v2/repositories/paritypr/";
const cache = new lru_cache_1.LRUCache({
    max: 50,
    ttl: 1000 * 60 * 5,
});
function constructCommandArgs(args, cliCommands) {
    const nodeCommands = [];
    const adapterCommands = [];
    if (cliCommands && Object.values(cliCommands).find((v) => v !== undefined)) {
        if (cliCommands.fork) {
            nodeCommands.push(`npx`);
            nodeCommands.push(`@acala-network/chopsticks@latest`);
            nodeCommands.push(`--endpoint=${cliCommands.fork}`);
        }
        else if (cliCommands.nodeBinaryPath) {
            nodeCommands.push(cliCommands.nodeBinaryPath);
        }
        if (cliCommands.rpcPort) {
            if (cliCommands.fork) {
                nodeCommands.push(`--port=${cliCommands.rpcPort}`);
            }
            else {
                nodeCommands.push(`--rpc-port=${cliCommands.rpcPort}`);
            }
            nodeCommands.push(`--rpc-port=${cliCommands.rpcPort}`);
            adapterCommands.push(`--node-rpc-url=ws://localhost:${cliCommands.rpcPort}`);
        }
        else {
            adapterCommands.push(`--node-rpc-url=ws://localhost:8000`);
        }
        if (cliCommands.adapterPort && cliCommands.adapterPort !== cliCommands.rpcPort) {
            adapterCommands.push(`--rpc-port=${cliCommands.adapterPort}`);
        }
        else if (cliCommands.adapterPort && cliCommands.adapterPort === cliCommands.rpcPort) {
            throw new errors_1.PolkadotNodePluginError("Adapter and node cannot share the same port.");
        }
        if (cliCommands.fork) {
            nodeCommands.push(`--build-block-mode=${cliCommands.buildBlockMode || "Instant"}`);
        }
        if (cliCommands.dev) {
            adapterCommands.push("--dev");
            if (cliCommands.nodeBinaryPath && !cliCommands.fork) {
                nodeCommands.push("--dev");
            }
        }
    }
    if (args && Object.values(args).find((v) => v !== undefined)) {
        if (args.forking && !cliCommands?.fork) {
            nodeCommands.push(`npx`);
            nodeCommands.push(`@acala-network/chopsticks@latest`);
            nodeCommands.push(`--endpoint=${args.forking.url}`);
        }
        else if (args.nodeCommands?.nodeBinaryPath && !cliCommands?.nodeBinaryPath) {
            nodeCommands.push(args.nodeCommands?.nodeBinaryPath);
        }
        if (args.nodeCommands?.rpcPort && !cliCommands?.rpcPort) {
            if (args.forking && !cliCommands?.fork) {
                nodeCommands.push(`--port=${args.nodeCommands.rpcPort}`);
            }
            else {
                nodeCommands.push(`--rpc-port=${args.nodeCommands.rpcPort}`);
            }
            adapterCommands.push(`--node-rpc-url=ws://localhost:${args.nodeCommands.rpcPort}`);
        }
        else if (!cliCommands?.rpcPort) {
            adapterCommands.push(`--node-rpc-url=ws://localhost:8000`);
        }
        if (args.adapterCommands?.adapterPort &&
            args.adapterCommands?.adapterPort !== args.nodeCommands?.rpcPort) {
            adapterCommands.push(`--rpc-port=${args.adapterCommands?.adapterPort}`);
        }
        else if (args.adapterCommands?.adapterPort &&
            args.adapterCommands?.adapterPort === args.nodeCommands?.rpcPort) {
            throw new errors_1.PolkadotNodePluginError("Adapter and node cannot share the same port.");
        }
        if (args.adapterCommands?.adapterPort &&
            args.adapterCommands?.adapterPort === args.nodeCommands?.rpcPort) {
            throw new errors_1.PolkadotNodePluginError("Adapter and node cannot share the same port.");
        }
        if (args.forking && !cliCommands?.buildBlockMode) {
            nodeCommands.push(`--build-block-mode=${args.adapterCommands?.buildBlockMode || "Instant"}`);
        }
        if (args.nodeCommands?.nodeBinaryPath && args.nodeCommands?.consensus) {
            if (args.nodeCommands.consensus.seal === "Manual") {
                nodeCommands.push(`--consensus=manual-seal-${args.nodeCommands.consensus.period || 50}`);
            }
            else {
                nodeCommands.push(`--consensus=${(args.nodeCommands.consensus.seal || "None").toLowerCase()}`);
            }
        }
        if (args.nodeCommands?.nodeBinaryPath &&
            args.nodeCommands.dev &&
            !cliCommands?.dev &&
            !args.forking) {
            nodeCommands.push(`--dev`);
        }
        if (args.adapterCommands?.dev && !cliCommands?.dev) {
            adapterCommands.push("--dev");
        }
    }
    return {
        nodeCommands,
        adapterCommands,
    };
}
async function isPortAvailableForIP(port, ip) {
    return new Promise((resolve) => {
        const tester = net_1.default
            .createServer()
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            .once("error", (err) => resolve(err.code !== "EADDRINUSE"))
            .once("listening", () => tester.close(() => resolve(true)))
            .listen(port, ip);
    });
}
async function isPortAvailable(port) {
    const availableIPv4 = await isPortAvailableForIP(port, "0.0.0.0");
    const availableIPv6 = await isPortAvailableForIP(port, "::");
    return availableIPv4 && availableIPv6;
}
async function getAvailablePort(startPort, maxAttempts) {
    let currentPort = startPort;
    for (let i = 0; i < maxAttempts; i++) {
        if (await isPortAvailable(currentPort)) {
            return currentPort;
        }
        currentPort++;
    }
    throw new errors_1.PolkadotNodePluginError("Couldn't find an available port after several attempts");
}
function adjustTaskArgsForPort(taskArgs, currentPort) {
    const portArg = "--port";
    const portArgIndex = taskArgs.indexOf(portArg);
    if (portArgIndex !== -1) {
        if (portArgIndex + 1 < taskArgs.length) {
            taskArgs[portArgIndex + 1] = `${currentPort}`;
        }
        else {
            throw new errors_1.PolkadotNodePluginError("Invalid task arguments: --port provided without a following port number.");
        }
    }
    else {
        taskArgs.push(portArg, `${currentPort}`);
    }
    return taskArgs;
}
function getNetworkConfig(url, chainId) {
    return {
        accounts: constants_1.NETWORK_ACCOUNTS.POLKADOT,
        gas: constants_1.NETWORK_GAS.AUTO,
        gasPrice: constants_1.NETWORK_GAS_PRICE.AUTO,
        gasMultiplier: 1,
        httpHeaders: {},
        timeout: 20000,
        url,
        ethNetwork: constants_1.NETWORK_ETH.LOCALHOST,
        chainId: chainId || 420420421,
    };
}
async function configureNetwork(config, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
network, port) {
    const url = `${constants_1.BASE_URL}:${port}`;
    const payload = {
        jsonrpc: "2.0",
        method: constants_1.RPC_ENDPOINT_PATH,
        params: [],
        id: 1,
    };
    let chainId = 0;
    try {
        const response = await axios_1.default.post(url, payload);
        if (response.status == 200) {
            chainId = parseInt(response.data.result);
        }
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
    }
    catch (_e) {
        // If it fails, it will just try again
    }
    network.name = constants_1.POLKADOT_TEST_NODE_NETWORK_NAME;
    network.config = getNetworkConfig(url, chainId);
    config.networks[network.name] = network.config;
    network.provider = await (0, construction_1.createProvider)(config, network.name);
}
async function startServer(commands, nodePath, adapterPath) {
    const currentNodePort = await getAvailablePort(commands.nodeCommands?.rpcPort ? commands.nodeCommands.rpcPort : constants_1.NODE_START_PORT, constants_1.MAX_PORT_ATTEMPTS);
    const currentAdapterPort = await getAvailablePort(commands.nodeCommands?.rpcPort ? commands.nodeCommands.rpcPort : constants_1.ETH_RPC_ADAPTER_START_PORT, constants_1.MAX_PORT_ATTEMPTS);
    const updatedCommands = Object.assign({}, commands, {
        nodeCommands: { port: currentNodePort },
        adapterCommands: { adapterPort: currentAdapterPort },
    });
    const commandArgs = constructCommandArgs(updatedCommands);
    return {
        commandArgs,
        server: (0, servers_1.createRpcServer)({
            nodePath,
            adapterPath: adapterPath || commands.adapterCommands?.adapterBinaryPath,
            isForking: commands.forking?.enabled,
        }),
        port: currentAdapterPort,
    };
}
/**
 * This function retrieves a list of the latest images available in the Docker registry
 * sortes them from newest to oldest, and returns the newest one, in order to be used by the DockerServer.
 */
async function getLatestImageName(containerName) {
    const cachedResult = cache.get(containerName);
    if (cachedResult) {
        return cachedResult;
    }
    const url = `${exports.PARITYPR_DOCKER_REGISTRY}${containerName}/tags?page_size=10`;
    const imageResponse = await axios_1.default.get(url, {
        timeout: 5000,
        responseType: "json",
    });
    if (imageResponse.status == 200) {
        const imageList = imageResponse.data;
        imageList.results
            .sort(
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        (a, b) => new Date(b.last_updated).getTime() - new Date(a.last_updated).getTime())
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            .map((tag) => tag.name);
        const latestImageName = imageList.results[0].name;
        if (latestImageName) {
            cache.set(containerName, latestImageName);
        }
        return latestImageName;
    }
    else {
        throw new Error(`Failed to fetch tags: ${imageResponse.statusText}`);
    }
}
//# sourceMappingURL=utils.js.map